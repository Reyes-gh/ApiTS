"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MySqlConfig_1 = require("@databases/mysql-config/lib/MySqlConfig");
const mysql_schema_introspect_1 = require("@databases/mysql-schema-introspect");
const assert_never_1 = require("assert-never");
const getTypeScriptType_1 = require("./getTypeScriptType");
function printTableDetails(type, context, options) {
    if (type.tableType !== mysql_schema_introspect_1.TableType.BaseTable) {
        throw new Error('printTableDetails only supports base tables at the moment.');
    }
    const DatabaseRecord = context.pushTypeDeclaration({ type: 'table', name: type.tableName }, (identifierName, file) => [
        ...getClassComment(type),
        `interface ${identifierName} {`,
        ...type.columns
            .map((column) => [
            ...getColumnComment(column),
            `  ${column.columnName}: ${getColumnType(type, column, context, file, options)}`,
        ])
            .reduce((a, b) => [...a, ...b], []),
        `}`,
    ]);
    const InsertParameters = context.pushTypeDeclaration({ type: 'insert_parameters', name: type.tableName }, (identifierName, file) => [
        ...getClassComment(type),
        `interface ${identifierName} {`,
        ...type.columns
            .map((column) => [
            ...getColumnComment(column),
            `  ${column.columnName}${optionalOnInsert(column)}: ${getColumnType(type, column, context, file, options)}`,
        ])
            .reduce((a, b) => [...a, ...b], []),
        `}`,
    ]);
    return { DatabaseRecord, InsertParameters };
}
exports.default = printTableDetails;
function getClassComment(table) {
    const commentLines = [];
    if (table.comment.trim()) {
        commentLines.push(...table.comment.trim().split('\n'));
    }
    if (commentLines.length) {
        return [`/**`, ...commentLines.map((l) => ` * ${l}`), ` */`];
    }
    else {
        return [];
    }
}
function getColumnComment(column) {
    const commentLines = [];
    if (column.comment.trim()) {
        commentLines.push(...column.comment.trim().split('\n'));
    }
    if (column.default) {
        if (commentLines.length)
            commentLines.push(``);
        commentLines.push(`@default ${column.default}`);
    }
    if (commentLines.length) {
        return [`  /**`, ...commentLines.map((l) => `   * ${l}`), `   */`];
    }
    else {
        return [];
    }
}
function getColumnType(type, column, context, file, options) {
    var _a;
    // Handle nullable columns
    if (column.isNullable) {
        return `(${getColumnType(type, { ...column, isNullable: false }, context, file, options)}) | null`;
    }
    // Handle column level overrides
    const columnTypeOverride = options.columnTypeOverrides[`${column.schemaName}.${column.tableName}.${column.columnName}`] ||
        options.columnTypeOverrides[`${column.tableName}.${column.columnName}`];
    if (columnTypeOverride) {
        return columnTypeOverride;
    }
    // Handle foreign keys
    const columnConstraints = type.constraints.filter((constraint) => constraint.columns.some((c) => c.columnName === column.columnName));
    for (const constraint of columnConstraints) {
        const referencedColumn = (_a = constraint.columns.find((c) => c.columnName === column.columnName && c.referenced !== null)) === null || _a === void 0 ? void 0 : _a.referenced;
        const referencedTable = referencedColumn
            ? options.getTable({
                schemaName: referencedColumn.schemaName,
                tableName: referencedColumn.tableName,
            })
            : null;
        if (referencedTable && referencedColumn) {
            const { DatabaseRecord } = printTableDetails(referencedTable, context, options);
            return `${file.getImport(DatabaseRecord)}['${referencedColumn.columnName}']`;
        }
    }
    // Handle primary keys
    if (column.isPrimaryKey) {
        return handleBrand(column, context, file, options);
    }
    return (0, getTypeScriptType_1.default)(column.type, options);
}
function optionalOnInsert(column) {
    if (column.isNullable)
        return '?';
    if (column.default !== null)
        return '?';
    return '';
}
function handleBrand(column, context, file, options) {
    const typeStr = `${(0, getTypeScriptType_1.default)(column.type, options)}${getBrand(column, options)}`;
    switch (options.primaryKeyTypeMode) {
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.strict_brand:
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.loose_brand:
            return file.getImport(context.pushTypeDeclaration({
                type: 'primary_key',
                name: column.tableName,
                columnName: column.columnName,
            }, (identifierName) => [`type ${identifierName} = ${typeStr}`]));
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_loose_brand:
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_strict_brand:
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_no_brand:
            return typeStr;
        default:
            return (0, assert_never_1.default)(options.primaryKeyTypeMode);
    }
}
function getBrand(column, options) {
    switch (options.primaryKeyTypeMode) {
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_loose_brand:
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.loose_brand:
            return ` & {readonly __brand?: '${column.tableName}_${column.columnName}'}`;
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_strict_brand:
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.strict_brand:
            return ` & {readonly __brand: '${column.tableName}_${column.columnName}'}`;
        case MySqlConfig_1.MySqlTypesPrimaryKeyTypeMode.inline_no_brand:
            return '';
        default:
            return (0, assert_never_1.default)(options.primaryKeyTypeMode);
    }
}
//# sourceMappingURL=printTableDetails.js.map