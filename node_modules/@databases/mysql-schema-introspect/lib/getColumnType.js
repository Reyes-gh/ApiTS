"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColumnTypeSchema = void 0;
const t = require("funtypes");
const DataType_1 = require("./enums/DataType");
const IntegerSchema = t.Number.withConstraint((value) => value !== Math.floor(value) ||
    Number.isNaN(value) ||
    value > Number.MAX_SAFE_INTEGER ||
    value < Number.MIN_SAFE_INTEGER
    ? `Expected an integer but got ${value.toString()}`
    : true, { name: `Integer` });
const aliases = new Map([
    [`geometrycollection`, DataType_1.default.geomcollection],
]);
const SimpleColumnTypeSchema = t.Named(`SimpleColumnType`, t.Object({
    kind: t.Union(t.Literal(DataType_1.default.bigint), t.Literal(DataType_1.default.blob), t.Literal(DataType_1.default.date), t.Literal(DataType_1.default.datetime), t.Literal(DataType_1.default.double), t.Literal(DataType_1.default.float), t.Literal(DataType_1.default.geometry), t.Literal(DataType_1.default.geomcollection), t.Literal(DataType_1.default.int), t.Literal(DataType_1.default.json), t.Literal(DataType_1.default.linestring), t.Literal(DataType_1.default.longblob), t.Literal(DataType_1.default.longtext), t.Literal(DataType_1.default.mediumblob), t.Literal(DataType_1.default.mediumint), t.Literal(DataType_1.default.mediumtext), t.Literal(DataType_1.default.multilinestring), t.Literal(DataType_1.default.multipoint), t.Literal(DataType_1.default.multipolygon), t.Literal(DataType_1.default.point), t.Literal(DataType_1.default.polygon), t.Literal(DataType_1.default.smallint), t.Literal(DataType_1.default.text), t.Literal(DataType_1.default.time), t.Literal(DataType_1.default.timestamp), t.Literal(DataType_1.default.tinyblob), t.Literal(DataType_1.default.tinyint), t.Literal(DataType_1.default.tinytext), t.Literal(DataType_1.default.year)),
}));
const DecimalTypeSchema = t.Named(`DecimalType`, t.Object({
    kind: t.Literal(DataType_1.default.decimal),
    /**
     * aka "numeric_precision"
     */
    digits: IntegerSchema,
    /**
     * aka "numeric_scale"
     */
    decimals: IntegerSchema,
}));
const EnumTypeSchema = t.Named(`Enum`, t.Object({
    kind: t.Literal(DataType_1.default.enum),
    values: t.Array(t.String),
}));
const SetTypeSchema = t.Named(`Set`, t.Object({
    kind: t.Literal(DataType_1.default.set),
    values: t.Array(t.String),
}));
const ColumnTypeWithLengthSchema = t.Named(`ColumnTypeWithLength`, t.Object({
    kind: t.Union(t.Literal(DataType_1.default.binary), t.Literal(DataType_1.default.bit), t.Literal(DataType_1.default.char), t.Literal(DataType_1.default.varbinary), t.Literal(DataType_1.default.varchar)),
    length: IntegerSchema,
}));
exports.ColumnTypeSchema = t.Union(SimpleColumnTypeSchema, DecimalTypeSchema, EnumTypeSchema, SetTypeSchema, ColumnTypeWithLengthSchema);
function getColumnType(column) {
    const alias = aliases.get(column.data_type);
    if (alias) {
        return getColumnType({ ...column, data_type: alias });
    }
    return exports.ColumnTypeSchema.parse(getColumnTypeInternal(column));
}
exports.default = getColumnType;
function getColumnTypeInternal(column) {
    switch (column.data_type) {
        case DataType_1.default.binary:
        case DataType_1.default.char:
        case DataType_1.default.varbinary:
        case DataType_1.default.varchar:
            if (!IntegerSchema.test(column.character_maximum_length)) {
                throw new Error(`Missing column.character_maximum_length for ${column.data_type}`);
            }
            return { kind: column.data_type, length: column.character_maximum_length };
        case DataType_1.default.bit:
            if (!IntegerSchema.test(column.numeric_precision)) {
                throw new Error(`Missing column.numeric_precision for ${column.data_type}: ${JSON.stringify(column)}`);
            }
            return {
                kind: column.data_type,
                length: column.numeric_precision,
            };
        case DataType_1.default.decimal:
            const match = /^decimal\((\d+),(\d+)\)/.exec(column.column_type);
            if (!match) {
                throw new Error(`Missing precision for ${column.data_type}: ${JSON.stringify(column)}`);
            }
            return {
                kind: column.data_type,
                digits: parseInt(match[1], 10),
                decimals: parseInt(match[2], 10),
            };
        case DataType_1.default.enum:
            return {
                kind: column.data_type,
                values: parseValuesList(column.column_type.substring(`enum`.length)),
            };
        case DataType_1.default.set:
            return {
                kind: column.data_type,
                values: parseValuesList(column.column_type.substring(`set`.length)),
            };
        // case DataType.bigint:
        // case DataType.int:
        // case DataType.mediumint:
        // case DataType.smallint:
        // case DataType.tinyint:
        // case DataType.year:
        //   return {kind: column.data_type};
        default:
            // if (column.data_type !== column.column_type) {
            //   throw new Error(`Unexpected column format: ${JSON.stringify(column)}`);
            // }
            return { kind: column.data_type };
    }
}
function parseValuesList(input) {
    const result = [];
    let rest = input.substring(1);
    let state = 'default';
    let current = '';
    while (rest) {
        switch (state) {
            case 'default':
                if (!rest.startsWith(`'`)) {
                    throw new Error(`Invalid values list: "${input}", expected "'" but got "${rest}"`);
                }
                rest = rest.substring(1);
                state = 'in_string';
                break;
            case 'in_string':
                if (rest.startsWith(`'`)) {
                    state = 'found_quote';
                    rest = rest.substring(1);
                }
                else {
                    current += rest[0];
                    rest = rest.substring(1);
                }
                break;
            case 'found_quote':
                if (rest.startsWith(`'`)) {
                    state = 'in_string';
                    current += `'`;
                    rest = rest.substring(1);
                }
                else {
                    state = 'in_list';
                    result.push(current);
                    current = '';
                }
                break;
            case 'in_list':
                if (rest.startsWith(`)`)) {
                    return result;
                }
                if (!rest.startsWith(`,'`)) {
                    throw new Error(`Invalid values list: "${input}"`);
                }
                rest = rest.substring(1);
                state = 'default';
                break;
        }
    }
    throw new Error(`Invalid values list: "${input}"`);
}
//# sourceMappingURL=getColumnType.js.map