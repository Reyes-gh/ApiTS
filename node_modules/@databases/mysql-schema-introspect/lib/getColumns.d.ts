import * as t from 'funtypes';
import { Queryable } from '@databases/mysql';
import { TableQuery } from './getTables';
export interface ColumnQuery extends Omit<TableQuery, 'type'> {
    columnName?: string;
}
declare const ColumnSchema: t.Object<{
    schemaName: t.String;
    tableName: t.String;
    columnName: t.String;
    ordinalPosition: t.Number;
    isPrimaryKey: t.Boolean;
    isNullable: t.Boolean;
    default: t.Union<[t.Literal<null>, t.String]>;
    type: t.Union<[t.Named<t.Object<{
        kind: t.Union<[t.Literal<import("./enums/DataType").default.bigint>, t.Literal<import("./enums/DataType").default.blob>, t.Literal<import("./enums/DataType").default.date>, t.Literal<import("./enums/DataType").default.datetime>, t.Literal<import("./enums/DataType").default.double>, t.Literal<import("./enums/DataType").default.float>, t.Literal<import("./enums/DataType").default.geometry>, t.Literal<import("./enums/DataType").default.geomcollection>, t.Literal<import("./enums/DataType").default.int>, t.Literal<import("./enums/DataType").default.json>, t.Literal<import("./enums/DataType").default.linestring>, t.Literal<import("./enums/DataType").default.longblob>, t.Literal<import("./enums/DataType").default.longtext>, t.Literal<import("./enums/DataType").default.mediumblob>, t.Literal<import("./enums/DataType").default.mediumint>, t.Literal<import("./enums/DataType").default.mediumtext>, t.Literal<import("./enums/DataType").default.multilinestring>, t.Literal<import("./enums/DataType").default.multipoint>, t.Literal<import("./enums/DataType").default.multipolygon>, t.Literal<import("./enums/DataType").default.point>, t.Literal<import("./enums/DataType").default.polygon>, t.Literal<import("./enums/DataType").default.smallint>, t.Literal<import("./enums/DataType").default.text>, t.Literal<import("./enums/DataType").default.time>, t.Literal<import("./enums/DataType").default.timestamp>, t.Literal<import("./enums/DataType").default.tinyblob>, t.Literal<import("./enums/DataType").default.tinyint>, t.Literal<import("./enums/DataType").default.tinytext>, t.Literal<import("./enums/DataType").default.year>]>;
    }, false>>, t.Named<t.Object<{
        kind: t.Literal<import("./enums/DataType").default.decimal>;
        digits: t.Constraint<t.Number, number, unknown>;
        decimals: t.Constraint<t.Number, number, unknown>;
    }, false>>, t.Named<t.Object<{
        kind: t.Literal<import("./enums/DataType").default.enum>;
        values: t.Array<t.String>;
    }, false>>, t.Named<t.Object<{
        kind: t.Literal<import("./enums/DataType").default.set>;
        values: t.Array<t.String>;
    }, false>>, t.Named<t.Object<{
        kind: t.Union<[t.Literal<import("./enums/DataType").default.binary>, t.Literal<import("./enums/DataType").default.bit>, t.Literal<import("./enums/DataType").default.char>, t.Literal<import("./enums/DataType").default.varbinary>, t.Literal<import("./enums/DataType").default.varchar>]>;
        length: t.Constraint<t.Number, number, unknown>;
    }, false>>]>;
    comment: t.String;
}, false>;
export declare type Column = t.Static<typeof ColumnSchema>;
export default function getColumns(connection: Queryable, query: ColumnQuery): Promise<Column[]>;
export {};
