import { SQLQuery, Queryable } from '@databases/mysql';
export interface SelectQuery<TRecord> {
    all(): Promise<TRecord[]>;
    orderByAsc(key: keyof TRecord): OrderedSelectQuery<TRecord>;
    orderByDesc(key: keyof TRecord): OrderedSelectQuery<TRecord>;
    select<TKeys extends readonly [keyof TRecord, ...(readonly (keyof TRecord)[])]>(...fields: TKeys): SelectQuery<Pick<TRecord, TKeys[number]>>;
}
export interface OrderedSelectQuery<TRecord> extends SelectQuery<TRecord> {
    first(): Promise<TRecord | null>;
    limit(count: number): Promise<TRecord[]>;
}
declare class FieldQuery<T> {
    protected readonly __query: (columnName: string, sql: Queryable['sql'], toValue: (columnName: string, value: unknown) => unknown) => SQLQuery;
    constructor(query: (columnName: string, sql: Queryable['sql'], toValue: (columnName: string, value: unknown) => unknown) => SQLQuery);
    protected __checkFieldType(): T;
    static query<T>(columnName: string, q: FieldQuery<T> | unknown, sql: Queryable['sql'], toValue: (columnName: string, value: unknown) => unknown): SQLQuery;
}
export type { FieldQuery };
export declare type WhereCondition<TRecord> = Partial<{
    [key in keyof TRecord]: TRecord[key] | FieldQuery<TRecord[key]>;
}>;
export declare function anyOf<T>(values: {
    [Symbol.iterator](): IterableIterator<T | FieldQuery<T>>;
}): FieldQuery<T>;
export declare function not<T>(value: T | FieldQuery<T>): FieldQuery<T>;
export declare function inQueryResults(query: SQLQuery): FieldQuery<any>;
export declare function lessThan<T>(value: T): FieldQuery<T>;
export declare function greaterThan<T>(value: T): FieldQuery<T>;
declare class Table<TRecord, TInsertParameters> {
    private readonly _underlyingDb;
    readonly tableId: SQLQuery;
    readonly tableName: string;
    private readonly _value;
    constructor(_underlyingDb: Queryable, tableId: SQLQuery, tableName: string, serializeValue: (columnName: string, value: unknown) => unknown);
    private _rowToWhere;
    insert<TRecordsToInsert extends readonly TInsertParameters[]>(...rows: keyof TRecordsToInsert[number] extends keyof TInsertParameters ? TRecordsToInsert : readonly ({
        [key in keyof TInsertParameters]: TInsertParameters[key];
    } & {
        [key in Exclude<keyof TRecordsToInsert[number], keyof TInsertParameters>]: never;
    })[]): Promise<void>;
    update(whereValues: WhereCondition<TRecord>, updateValues: Partial<TRecord>): Promise<void>;
    delete(whereValues: WhereCondition<TRecord>): Promise<void>;
    find(whereValues?: WhereCondition<TRecord>): SelectQuery<TRecord>;
    findOne(whereValues: WhereCondition<TRecord>): Promise<TRecord | null>;
    count(whereValues?: WhereCondition<TRecord>): Promise<number>;
    untypedQuery(query: SQLQuery): Promise<TRecord[]>;
}
export type { Table };
export interface MySqlTypedOptions {
    serializeValue?: (tableName: string, columnName: string, value: unknown) => unknown;
}
export interface MySqlTypedOptionsWithDefaultConnection extends MySqlTypedOptions {
    defaultConnection: Queryable;
}
export default function tables<TTables>(options: MySqlTypedOptionsWithDefaultConnection): {
    [TTableName in keyof TTables]: (connectionOrTransaction?: Queryable) => Table<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>>;
};
export default function tables<TTables>(options?: MySqlTypedOptions): {
    [TTableName in keyof TTables]: (connectionOrTransaction: Queryable) => Table<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>>;
};
declare type PropertyOf<T, TProp extends string> = T extends {
    [k in TProp]: infer TValue;
} ? TValue : never;
