"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.greaterThan = exports.lessThan = exports.inQueryResults = exports.not = exports.anyOf = void 0;
class FieldQuery {
    constructor(query) {
        this.__query = query;
    }
    __checkFieldType() {
        throw new Error('This method is only there to help TypeScript interpret the type');
    }
    static query(columnName, q, sql, toValue) {
        if (q === null) {
            return sql `${sql.ident(columnName)} IS NULL`;
        }
        if (q && q instanceof FieldQuery) {
            return q.__query(columnName, sql, toValue);
        }
        return sql `${sql.ident(columnName)} = ${toValue(columnName, q)}`;
    }
}
function anyOf(values) {
    const valuesArray = [];
    const parts = [];
    for (const value of values) {
        if (value === null) {
            parts.push(new FieldQuery((columnName, sql, toValue) => FieldQuery.query(columnName, null, sql, toValue)));
        }
        else if (value instanceof FieldQuery) {
            parts.push(value);
        }
        else {
            valuesArray.push(value);
        }
    }
    if (valuesArray.length) {
        parts.push(new FieldQuery((columnName, sql, toValue) => sql `${sql.ident(columnName)} IN (${valuesArray.map((v) => toValue(columnName, v))})`));
    }
    if (parts.length === 0) {
        return new FieldQuery((_columnName, sql) => sql `FALSE`);
    }
    if (parts.length === 1) {
        return parts[0];
    }
    return new FieldQuery((columnName, sql, toValue) => sql `(${sql.join(parts.map((p) => FieldQuery.query(columnName, p, sql, toValue)), ' OR ')})`);
}
exports.anyOf = anyOf;
function not(value) {
    return new FieldQuery((columnName, sql, toValue) => sql `NOT (${FieldQuery.query(columnName, value, sql, toValue)})`);
}
exports.not = not;
function inQueryResults(query) {
    return new FieldQuery((columnName, sql) => sql `${sql.ident(columnName)} IN (${query})`);
}
exports.inQueryResults = inQueryResults;
function lessThan(value) {
    return new FieldQuery((columnName, sql, toValue) => sql `${sql.ident(columnName)} < ${toValue(columnName, value)}`);
}
exports.lessThan = lessThan;
function greaterThan(value) {
    return new FieldQuery((columnName, sql, toValue) => sql `${sql.ident(columnName)} > ${toValue(columnName, value)}`);
}
exports.greaterThan = greaterThan;
class SelectQueryImplementation {
    constructor(_sql, _tableID, _where, _executeQuery) {
        this._sql = _sql;
        this._tableID = _tableID;
        this._where = _where;
        this._executeQuery = _executeQuery;
        this.orderByQueries = [];
    }
    async _getResults(mode) {
        if (this._methodCalled) {
            throw new Error(`You cannot use the same query multiple times. ${this._methodCalled} has already been called on this query.`);
        }
        this._methodCalled = mode;
        const sql = this._sql;
        const parts = [
            this._selectFields
                ? sql `SELECT ${this._selectFields} FROM ${this._tableID} ${this._where}`
                : sql `SELECT * FROM ${this._tableID} ${this._where}`,
        ];
        if (this.orderByQueries.length) {
            parts.push(sql `ORDER BY ${sql.join(this.orderByQueries, sql `, `)}`);
        }
        if (this.limitCount) {
            parts.push(sql `LIMIT ${this.limitCount}`);
        }
        return this._executeQuery(parts.length === 1 ? parts[0] : sql.join(parts, sql ` `));
    }
    orderByAsc(key) {
        const sql = this._sql;
        this.orderByQueries.push(sql `${sql.ident(key)} ASC`);
        return this;
    }
    orderByDesc(key) {
        const sql = this._sql;
        this.orderByQueries.push(sql `${sql.ident(key)} DESC`);
        return this;
    }
    select(...fields) {
        if (this._selectFields) {
            throw new Error('Cannot call select fields multiple times on one query');
        }
        this._selectFields = this._sql.join(fields.map((f) => this._sql.ident(f)), ',');
        return this;
    }
    async all() {
        return await this._getResults('all');
    }
    async limit(count) {
        if (!this.orderByQueries.length) {
            throw new Error('You cannot call "limit" until after you call "orderByAsc" or "orderByDesc".');
        }
        this.limitCount = count;
        return await this._getResults('limit');
    }
    async first() {
        if (!this.orderByQueries.length) {
            throw new Error('You cannot call "first" until after you call "orderByAsc" or "orderByDesc".');
        }
        this.limitCount = 1;
        const results = await this._getResults('first');
        return results.length ? results[0] : null;
    }
}
class Table {
    constructor(_underlyingDb, tableId, tableName, serializeValue) {
        this._underlyingDb = _underlyingDb;
        this.tableId = tableId;
        this.tableName = tableName;
        this._value = (c, v) => serializeValue(c, v);
    }
    _rowToWhere(row) {
        const { sql } = this._underlyingDb;
        const entries = Object.entries(row).filter((row) => row[1] !== undefined);
        if (entries.length === 0) {
            return sql ``;
        }
        return sql `WHERE ${sql.join(entries.map(([columnName, value]) => FieldQuery.query(columnName, value, sql, this._value)), sql ` AND `)}`;
    }
    async insert(...rows) {
        if (rows.length === 0)
            return;
        const { sql } = this._underlyingDb;
        const columnNamesSet = new Set();
        for (const row of rows) {
            for (const columnName of Object.keys(row)) {
                columnNamesSet.add(columnName);
            }
        }
        const columnNames = [...columnNamesSet].sort();
        const columnNamesSql = sql.join(columnNames.map((columnName) => sql.ident(columnName)), sql `, `);
        const values = rows.map((row) => sql `(${sql.join(columnNames.map((columnName) => columnName in row
            ? sql.value(this._value(columnName, row[columnName]))
            : sql `DEFAULT`), `,`)})`);
        await this._underlyingDb.query(sql `INSERT INTO ${this.tableId} (${columnNamesSql}) VALUES ${sql.join(values, `,`)}`);
    }
    async update(whereValues, updateValues) {
        const { sql } = this._underlyingDb;
        const where = this._rowToWhere(whereValues);
        const setClause = sql.join(Object.entries(updateValues).map(([columnName, value]) => {
            return sql `${sql.ident(columnName)} = ${this._value(columnName, value)}`;
        }), sql `, `);
        await this._underlyingDb.query(sql `UPDATE ${this.tableId} SET ${setClause} ${where}`);
    }
    async delete(whereValues) {
        const { sql } = this._underlyingDb;
        const where = this._rowToWhere(whereValues);
        await this._underlyingDb.query(sql `DELETE FROM ${this.tableId} ${where}`);
    }
    find(whereValues = {}) {
        const { sql } = this._underlyingDb;
        const where = this._rowToWhere(whereValues);
        return new SelectQueryImplementation(sql, this.tableId, where, async (query) => await this._underlyingDb.query(query));
    }
    // throws if > 1 row matches
    async findOne(whereValues) {
        const rows = await this.find(whereValues).all();
        if (rows.length >= 2) {
            throw new Error('More than one row matched this query but you used `.findOne`.');
        }
        if (rows.length !== 1) {
            return null;
        }
        return rows[0];
    }
    async count(whereValues = {}) {
        const { sql } = this._underlyingDb;
        const where = this._rowToWhere(whereValues);
        const [result] = await this._underlyingDb.query(sql `SELECT count(*) AS count FROM ${this.tableId} ${where}`);
        return parseInt(`${result.count}`, 10);
    }
    async untypedQuery(query) {
        return await this._underlyingDb.query(query);
    }
}
function getTable(tableName, defaultConnection, serializeValue) {
    return (queryable = defaultConnection) => {
        if (!queryable) {
            throw new Error('You must either provide a "defaultConnection" to mysql-typed, or specify a connection when accessing the table.');
        }
        return new Table(queryable, queryable.sql.ident(tableName), tableName, serializeValue);
    };
}
function tables(options = {}) {
    return new Proxy({}, {
        get: (_target, prop, _receiver) => {
            if (prop === 'then') {
                return undefined;
            }
            const tableName = String(prop);
            return getTable(tableName, options.defaultConnection, getTableSerializeValue(tableName, options.serializeValue));
        },
    });
}
exports.default = tables;
function getTableSerializeValue(tableName, serializeValue) {
    return serializeValue
        ? (columnName, value) => serializeValue(tableName, columnName, value)
        : (_, value) => value;
}
module.exports = Object.assign(tables, {
    default: tables,
    anyOf,
    not,
    inQueryResults,
    lessThan,
    greaterThan,
});
//# sourceMappingURL=index.js.map